{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/components/grid.js","webpack:///./js/components/heap.js","webpack:///./js/components/node.js","webpack:///./js/generators/master_generator.js","webpack:///./js/index.js","webpack:///./js/solvers/a_star_solver.js","webpack:///./js/solvers/dfs_bfs_solver.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AChEA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;ACtCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;;;ACPD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/index.js\");\n","import Node from './node';\n\nclass Grid {\n  constructor(gridDimensions){\n    this.xDim = gridDimensions[0];\n    this.yDim = gridDimensions[1];\n    this.matrix = this.constructMatrix();\n  }\n\n  constructMatrix() {\n    let matrix = [];\n\n    for(let i = 0; i < this.yDim; i++) {\n      let row = [];\n      for(let j = 0; j < this.xDim; j++) {\n        const node = new Node([j, i], null);\n        row.push(node);\n      }\n      matrix.push(row);\n    }\n\n    return matrix;\n  }\n\n  inBounds(x, y){\n    return (x >= 0 && x < this.xDim) && (y >= 0 && y < this.yDim)\n  }\n\n  canPlace(node) {\n    return !this.matrix[node.x][node.y].onPath;\n  }\n\n  continuePath(node, ctx) {\n    node.onPath = true;\n    this.matrix[node.x][node.y] = node;\n    this.drawPath(ctx, node, \"#2ae950\");\n  }\n\n  drawSolution (root, target, ctx) {\n    const path = [target];\n    while(path[0].x !== root.x || path[0].y !== root.y) {\n      let node = path[0].parent;\n      path.unshift(node);\n    }\n\n    const drawStep = () => {\n      path.forEach(node => {\n        debugger\n        this.drawPath(ctx, node, '#ff2103')\n      });\n    }\n\n    const timer = setInterval(drawStep, 0);\n  }\n\n  drawPath(ctx, node, color) {\n    ctx.fillStyle = color;\n    if(node.parent_connector){\n      ctx.fillRect(node.parent_connector.x * 5, node.parent_connector.y * 5, 5, 5);\n    }\n    ctx.fillRect(node.x * 5, node.y * 5, 5, 5);\n  }\n}\n\nexport default Grid;\n","class Heap {\n  constructor(comparator, root) {\n    this.comparator = comparator;\n    this.array = [root];\n    this.length = 1;\n  }\n\n  shift() {\n    this.length--;\n    return this.array.shift();\n  }\n\n  push(node) {\n    this.array.push(node);\n    this.length++;\n    this.heapify();\n  }\n\n  swap(x, y) {\n    let temp = this.array[x];\n    this.array[x] = this.array[y];\n    this.array[y] = temp;\n  }\n\n  heapify() {\n    let index = this.length - 1;\n    let parentIndex = Math.floor((index - 1) / 2);\ndebugger\n    while(parentIndex > -1 && this.comparator(this.array[parentIndex], this.array[index])) {\n      debugger\n      this.swap(parentIndex, index);\n      index = parentIndex;\n      parentIndex =  Math.floor((index - 1) / 2);\n    }\n  }\n\n}\n\nexport default Heap;\n","class Node {\n  constructor(rootCoords, onPath) {\n    this.x = rootCoords[0];\n    this.y = rootCoords[1];\n    this.onPath = onPath;\n    this.parent = null;\n    this.parent_connector = null;\n    this.children = null;\n    this.adjacentCoords = [\n      [this.x + 2, this.y],\n      [this.x - 2, this.y],\n      [this.x, this.y + 2],\n      [this.x, this.y - 2]\n    ]\n    this.gVal = null;\n    this.hVal = null;\n    this.fVal = null;\n  }\n\n  generateChildren(grid) {\n    this.children = this.adjacentCoords.map(coords => {\n      const child = new Node(coords, null);\n      child.parent = this;\n      const parent_connector = new Node ([(child.x + child.parent.x) / 2, (child.y + child.parent.y) / 2], null);\n      child.parent_connector = parent_connector;\n\n      return child;\n    }).filter(child => {\n      return grid.inBounds(child.x, child.y);\n    });\n  }\n\n}\n\nexport default Node;\n","import Grid from '../components/grid';\nimport Node from '../components/node';\nimport dfs_bfs_solver from '../solvers/dfs_bfs_solver';\nimport a_star_solver from '../solvers/a_star_solver';\n\nconst generate_maze = (canvas, rootCoords, gridDimensions) => {\n  //\n  const grid = new Grid(gridDimensions);\n  const root = new Node(rootCoords, null);\n  const ctx = canvas.getContext('2d');\n  let options = [root];\n\n  const generationStep = () => {\n    // if(options.length === 0) {\n    //   window.clearInterval(timer);\n    //   dfs_bfs_solver(ctx, root, grid.matrix[99][99], 'dfs');\n    //   return;\n    // };\n\n    let randomIndex = Math.floor(Math.random() * options.length);\n    let selected = options.splice(randomIndex, 1)[0];\n\n    if(grid.canPlace(selected)) {\n      grid.continuePath(selected, ctx);\n      selected.generateChildren(grid);\n      options = options.concat(selected.children);\n    }\n  }\n\n  while(options.length > 0){\n    generationStep();\n  }\n  debugger\n  a_star_solver(ctx, root, grid.matrix[98][98], 'dfs', grid);\n\n  // const timer = window.setInterval(generationStep, 0);\n}\n\nexport default generate_maze;\n","import generate_maze from './generators/master_generator';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvas = document.getElementById('maze');\n  canvas.addEventListener(\"click\", () => {\n    generate_maze(canvas, [50, 50], [100, 100]);\n  });\n});\n","import Heap from '../components/heap';\n\nconst a_star_solver = (ctx, root, target, algo, grid) => {\n  const euclideanDist = (current, target) => {\n    return Math.sqrt(\n      Math.pow((target.x - current.x), 2) +\n      Math.pow((target.y - current.y), 2)\n    )\n  };\n\n  const comparator = (node1, node2) => {\n    return node1.fVal > node2.fVal;\n  }\n\n  root.gVal = 0;\n  let options = new Heap(comparator, root);\n\n  const solutionStep = () => {\n    let selected = options.shift();\n\n    grid.drawPath(ctx, selected, \"#000000\");\n    if(selected.x === target.x && selected.y === target.y) {\n\n      grid.drawSolution(root, target, ctx);\n      clearInterval(timer);\n    }\n\n    selected.children.forEach(child => {\n      if (child.onPath) {\n        child.gVal = child.parent.gVal + 1;\n        child.hVal = euclideanDist(child, target);\n        child.fVal = child.gVal + child.hVal;\n        options.push(child);\n      };\n    });\n  }\n\n  const timer = setInterval(solutionStep, 0);\n}\n\nexport default a_star_solver;\n","\n\nconst dfs_bfs_solver = (ctx, root, target, algo, grid) => {\n  let options = [root];\n\n  const solutionStep = () => {\n    let selected = algo === 'dfs' ? options.pop() : options.shift();\n    debugger\n    grid.drawPath(ctx, selected, \"#000000\");\n    if(selected.x === target.x && selected.y === target.y) {\n      debugger\n      grid.drawSolution(root, target, ctx);\n      clearInterval(timer);\n    }\n\n    selected.children.forEach(child => {\n      if (child.onPath) {\n        options.push(child);\n      };\n    });\n  }\n\n  const timer = setInterval(solutionStep, 0);\n}\n\nexport default dfs_bfs_solver;\n"],"sourceRoot":""}