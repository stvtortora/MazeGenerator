{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/button_util.js","webpack:///./js/components/disjoint_set.js","webpack:///./js/components/grid.js","webpack:///./js/components/min_heap.js","webpack:///./js/components/node.js","webpack:///./js/generators/kruskals_generator.js","webpack:///./js/generators/master_generator.js","webpack:///./js/generators/prims_dfs_generator.js","webpack:///./js/generators/randomized_dfs_generator.js","webpack:///./js/index.js","webpack:///./js/mazeHandlers.js","webpack:///./js/solvers/maze_solver.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACZA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACXA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9EA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;AC3CA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;;;AAIA;;;;;;;;;;;;;;;;AC3EA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;;AAGA;;;;;;;;;;;;;;;;ACjBA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACzCA;AACA;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA,CAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;;;;;;;;;;;;;;;;;;;AC9BJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;;;;AC7EA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/index.js\");\n","const changeButtonStatus = (status, onlySolvers = false) => {\n  const buttons = document.getElementsByTagName('button');\n\n  for (let i = 0; i < buttons.length; i++) {\n    const button = buttons[i];\n    \n    if (!onlySolvers || button.getAttribute('class') === 'solver') {\n      button.disabled = status;\n    }\n  }\n}\n\nexport default changeButtonStatus;\n","class DisjointSet {\n\n  joined(node1, node2) {\n    return node1.setRoot() === node2.setRoot();\n  }\n\n  merge(set1, set2) {\n    set2.setRoot().setParent = set1.setRoot();\n  }\n}\n\nexport default DisjointSet;\n","import Node from './node';\n\nclass Grid {\n  constructor(gridDimensions){\n    this.xDim = gridDimensions[0];\n    this.yDim = gridDimensions[1];\n    this.matrix = this.constructMatrix();\n  }\n\n  constructMatrix() {\n    let matrix = [];\n\n    for(let i = 0; i < this.yDim; i++) {\n      let row = [];\n      for(let j = 0; j < this.xDim; j++) {\n        const node = new Node([i, j], null);\n        row.push(node);\n      }\n      matrix.push(row);\n    }\n\n    return matrix;\n  }\n\n  inBounds(x, y){\n    return (x >= 0 && x < this.xDim) && (y >= 0 && y < this.yDim)\n  }\n\n  openAt(x, y) {\n    return !this.matrix[x][y].onPath;\n  }\n\n  continuePath(node, ctx) {\n    this.matrix[node.x][node.y] = node;\n    node.onPath = true;\n    if(node.parent_connector) {\n      node.parent_connector.onPath = true;\n    }\n    this.drawPath(ctx, node, \"#2ae950\");\n  }\n\n  clearSolution (ctx, node) {\n    for (let i = 0; i < this.yDim; i++) {\n      for (let j = 0; j < this.xDim; j++) {\n        const node = this.matrix[i][j];\n        if (node.onPath) {\n          this.drawPath(ctx, node, \"#2ae950\");\n        }\n      }\n    }\n  }\n\n  drawSolution (root, target, ctx) {\n    const path = [target];\n    while(path[0].x !== root.x || path[0].y !== root.y) {\n      let node = path[0].parent;\n      path.unshift(node);\n    }\n\n    const drawStep = () => {\n      path.forEach(node => {\n        this.drawPath(ctx, node, '#ff2103');\n      });\n    }\n\n    drawStep();\n  }\n\n  drawPath(ctx, node, color) {\n    const multiplier = 10;\n    ctx.fillStyle = color;\n    if(node.parent_connector){\n      ctx.fillRect(node.parent_connector.x * multiplier, node.parent_connector.y * multiplier, multiplier, multiplier);\n    }\n    ctx.fillRect(node.x * multiplier, node.y * multiplier, multiplier, multiplier);\n  }\n}\n\nexport default Grid;\n","class MinHeap {\n  constructor(comparator, root) {\n    this.comparator = comparator;\n    this.array = [root];\n    this.length = 1;\n    this.removed = null;\n  }\n\n  shift() {\n    this.swap(0, this.length - 1);\n    this.removed = this.array.pop();\n    this.length--;\n    this.heapifyDown();\n    return this.removed;\n  }\n\n  push(node) {\n    this.array.push(node);\n    this.length++;\n    this.heapifyUp();\n  }\n\n  swap(x, y) {\n    let temp = this.array[x];\n    this.array[x] = this.array[y];\n    this.array[y] = temp;\n  }\n\n  heapifyUp() {\n    let index = this.length - 1;\n    let parentIndex = Math.floor((index - 1) / 2);\n\n    while(parentIndex > -1 && this.comparator(this.array[parentIndex], this.array[index])) {\n      this.swap(parentIndex, index);\n      index = parentIndex;\n      parentIndex =  Math.floor((index - 1) / 2);\n    }\n  }\n\n  heapifyDown() {\n    let index = 0;\n    let child1Index = 1;\n    let child2Index = 2;\n    let priorityChildIndex = this.priorityChildIndex(child1Index, child2Index);\n\n    while(priorityChildIndex && this.comparator(this.array[index], this.array[priorityChildIndex])) {\n      this.swap(index, priorityChildIndex);\n\n      index = priorityChildIndex;\n      child1Index = (priorityChildIndex * 2) + 1;\n      child2Index = (priorityChildIndex * 2) + 2;\n      priorityChildIndex = this.priorityChildIndex(child1Index, child2Index);\n    }\n  }\n\n  priorityChildIndex(index1, index2) {\n    if(index1 < this.length) {\n\n      if(index2 >= this.length) {\n        return index1;\n      }\n\n      return this.array[index1].fVal < this.array[index2].fVal ? index1 : index2;\n    }\n    return null;\n  }\n}\n\nexport default MinHeap;\n","class Node {\n  constructor(rootCoords, onPath) {\n    this.x = rootCoords[0];\n    this.y = rootCoords[1];\n    this.onPath = onPath;\n    this.parent = null;\n    this.parent_connector = null;\n    this.children = [];\n    this.adjacentCoords = [\n      [this.x + 2, this.y],\n      [this.x - 2, this.y],\n      [this.x, this.y + 2],\n      [this.x, this.y - 2]\n    ]\n    this.gVal = null;\n    this.hVal = null;\n    this.fVal = null;\n    this.setParent = null;\n  }\n\n  generateChild(coords) {\n    const child = new Node(coords, null);\n    child.parent = this;\n    const parent_connector = new Node ([(child.x + child.parent.x) / 2, (child.y + child.parent.y) / 2], null);\n    child.parent_connector = parent_connector;\n\n    this.children.push(child);\n  }\n\n  generateChildren(grid) {\n    this.adjacentCoords.forEach(coords => {\n      if(grid.inBounds(coords[0], coords[1])){\n        this.generateChild(coords);\n      }\n    });\n  }\n\n  setRoot() {\n    return this.setParent ? this.setParent.setRoot() : this;\n  }\n\n}\n\nexport default Node;\n","import DisjointSet from '../components/disjoint_set';\n\nconst kruskals_generator = (grid, root, ctx, algo) => {\n  const disjointSet = new DisjointSet;\n  const flatten = (array) => {\n    let flattened = [];\n\n    for (let i = 0; i < array.length; i++) {\n      const el = array[i];\n      if (Array.isArray(el)){\n        flattened = flattened.concat(flatten(el));\n      } else{\n        flattened.push(el);\n      }\n    }\n\n    return flattened;\n  }\n\n  const rejectWalls = (nodes) => {\n    return nodes.filter(node => {\n      return node.x % 2 === 0 && node.y % 2 === 0;\n    });\n  }\n\n  const shuffle = (array) => {\n    for(let i = 0; i < array.length; i++) {\n      let j = Math.floor(Math.random() * array.length);\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n  }\n\n  let options = rejectWalls(flatten(grid.matrix));\n\n  const generationStep = () => {\n    if(options.length === 0) {\n      window.clearInterval(timer);\n      return;\n    };\n\n    let randomIndex = Math.floor(Math.random() * options.length);\n    const selected = options[randomIndex];\n\n    if(selected.adjacentCoords.length > 0){\n      let randomIndex = Math.floor(Math.random() * selected.adjacentCoords.length);\n      const coords = selected.adjacentCoords.splice(randomIndex, 1)[0];\n\n      if(grid.inBounds(coords[0], coords[1])){\n        const neighbor = grid.matrix[coords[0]][coords[1]];\n\n        if(!disjointSet.joined(selected, neighbor)){\n\n          disjointSet.merge(selected, neighbor);\n          neighbor.parent = selected;\n          // selected.children.push(neighbor);\n\n          neighbor.parent_connector = grid.matrix[(neighbor.x + selected.x) / 2][(neighbor.y + selected.y) / 2];\n          grid.continuePath(selected, ctx);\n          grid.continuePath(neighbor, ctx);\n        }\n\n      }\n\n    } else{\n      options.splice(randomIndex, 1);\n    }\n\n  }\n\n  const timer = setInterval(generationStep, 0);\n}\n\n\n\nexport default kruskals_generator;\n","import Grid from '../components/grid';\nimport Node from '../components/node';\n\n//second argument was canvasId, now its the context\nconst maze = (maze_generator, ctx, width, height, rootCoords, gridDimensions, solve_algo, gen_algo) => {\n  // const canvas = document.getElementById(canvasId);\n\n  // canvas.addEventListener(\"click\", ()=> {\n    const grid = new Grid(gridDimensions);\n    const root = new Node(rootCoords, null);\n    // const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, width, height);\n    maze_generator(grid, root, ctx, solve_algo, gen_algo);\n  // });\n}\n\n\nexport default maze;\n","import maze_solver from '../solvers/maze_solver';\nimport changeButtonStatus from '../button_util';\n\nconst primsDfsGenerator = (grid, root, ctx, solve_algo, gen_algo) => {\n\n  let options = [root];\n\n  const generationStep = () => {\n    if(options.length === 0) {\n      changeButtonStatus(false);\n      window.clearInterval(timer);\n      return;\n    };\n\n    let selected;\n    if(gen_algo === 'prims') {\n      let randomIndex = Math.floor(Math.random() * options.length);\n      selected = options.splice(randomIndex, 1)[0];\n    } else{\n      selected = options.pop();\n    }\n\n    if(grid.openAt(selected.x, selected.y)) {\n      grid.continuePath(selected, ctx);\n      selected.generateChildren(grid);\n      options = options.concat(selected.children);\n    }\n  }\n\n  let timer;\n  if(solve_algo){\n    while(options.length > 0){\n      generationStep();\n      changeButtonStatus(false);\n    }\n    // maze_solver(ctx, grid.matrix[0][0], grid.matrix[48][48], grid, solve_algo);\n  } else {\n      timer = setInterval(generationStep, 0);\n  }\n\n}\nexport default primsDfsGenerator;\n","import maze_solver from '../solvers/maze_solver';\nimport changeButtonStatus from '../button_util';\n\nconst randomized_dfs_generator = (grid, root, ctx, algo) => {\n  const shuffle = (array) => {\n    for(let i = 0; i < array.length; i++) {\n      let j = Math.floor(Math.random() * array.length);\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n  }\n\n  grid.continuePath(root, ctx);\n  let options = [root];\n\n  const generationStep = () => {\n    if(options.length === 0) {\n      window.clearInterval(timer);\n      changeButtonStatus(false);\n      return;\n    };\n\n    const parent = options[options.length - 1];\n    const childCoords = shuffle(parent.adjacentCoords);\n    let checked = 0\n    let selected = null;\n\n    while(checked < childCoords.length && !selected){\n      let coords = childCoords[checked];\n\n      if(grid.inBounds(coords[0], coords[1]) && grid.openAt(coords[0], coords[1])){\n\n        parent.generateChild(coords);\n        let child = parent.children[parent.children.length - 1];\n        grid.continuePath(child, ctx);\n        selected = child;\n\n      }\n\n      checked++;\n    }\n\n    selected ? options.push(selected) : options.pop();\n  }\n\n  let timer;\n  if (algo) {\n    while(options.length > 0){\n      generationStep();\n      changeButtonStatus(false);\n    }\n  } else {\n    timer = setInterval(generationStep, 0);\n  }\n}\n\n\nexport default randomized_dfs_generator;\n","import maze from './generators/master_generator';\nimport primsDfsGenerator from './generators/prims_dfs_generator';\nimport randomized_dfs_generator from './generators/randomized_dfs_generator';\nimport kruskals_generator from './generators/kruskals_generator';\nimport mazeHandlers from './mazeHandlers';\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const canvas = document.getElementById('1');\n\n    mazeHandlers(canvas);\n});\n\n\n\n// maze(primsDfsGenerator, '1', [0, 0], [50, 50], null, 'dfs');\n// maze(randomized_dfs_generator, '2', [24, 24], [50, 50], null);\n// maze(primsDfsGenerator, '3', [24, 24], [50, 50], null, 'prims');\n// maze(kruskals_generator, '4', [0, 0], [50, 50], 'dfs', 'dfs');\n// maze(primsDfsGenerator, '5', [0, 0], [50, 50], 'dfs', 'prims');\n// maze(primsDfsGenerator, '6', [0, 0], [50, 50], 'bfs', 'prims');\n// maze(primsDfsGenerator, '7', [0, 0], [50, 50], 'a*', 'prims');\n\n// const mazeIds = ['1', '2', '3', '4', '5', '6', '7'].forEach(id => {\n//   const canvas = document.getElementById(id);\n//   const ctx = canvas.getContext('2d');\n//   ctx.font = '30px sans-serif'\n//   ctx.fillStyle = 'white';\n//   ctx.fillText(\"Click to View Maze\", 100, canvas.height/2);\n// });\n","import maze from './generators/master_generator';\nimport primsDfsGenerator from './generators/prims_dfs_generator';\nimport randomized_dfs_generator from './generators/randomized_dfs_generator';\nimport changeButtonStatus from './button_util';\nimport maze_solver from './solvers/maze_solver';\nimport Grid from './components/grid';\nimport Node from './components/node';\n\n\nconst mazeHandlers = (canvas) => {\n  changeButtonStatus(true, true);\n\n  const quickGenerators = [primsDfsGenerator, randomized_dfs_generator];\n  const ctx = canvas.getContext('2d');\n  const width = canvas.width;\n  const height = canvas.height;\n  let grid;\n  let root;\n\n  const generateMaze = (solve_algo, gen_algo, generator, rootCoords = [0, 0]) => {\n    grid = new Grid([50, 50]);\n    root = new Node(rootCoords, null);\n    ctx.clearRect(0, 0, width, height);\n\n    changeButtonStatus(true);\n\n    generator(grid, root, ctx, solve_algo, gen_algo);\n  }\n\n  const descriptions = {\n    'prims': \"<p class='algo-title'>Prim's Algorithm</p><p/>1. Choose a node as the root, and store it in a set.<br/>2. Select the node in the set that would result in the least cost* to travel to.<br/>3. Add the node to the maze unless it will cause a loop.<br/>4. Add the node's neighbors to the set.<br/>4. Remove the node from the set.<br/>5. Repeat steps 2-4 until the set is empty.<br/><br/>* Since nodes are evenly spaced, the cost of travelling to a neighboring node is always the same. Consequetly, we simply choose a random node from the set.\",\n    'strict_dfs': \"<p class='algo-title'>Strict DFS<p> 1. Initialize a stack with a single node.<br/>2. Pop a node from the stack. <br/>3. Push each of the node's unvisited neighbors onto the stack.<br/>4. Repeat step two onward until the stack is empty. <br/></p>\",\n    'randomized_dfs': \"<p class='algo-title'>Depth First Traversal</p><p> 1. Initialize a stack with a single node.<br/>2. Look at the next node on the stack.<br/>3. If the node has unvisited neighbors, push a random one onto the stack. Else, pop the node from the stack.<br/>4. Repeat step two onward until the stack is empty. <br/></p>\",\n    'dfs_solver': \"<p class='algo-title'>Depth First Search</p><p> 1. Initialize a stack with a single node.<br/>2. Pop a node from the stack. <br/>3. Push each of the node's unvisited neighbors onto the stack.<br/><br/>4. Repeat step two onward until the target is found. <br/><br/></p>\",\n    'bfs_solver': \"<p class='algo-title'>Breadth First Search</p><p>BFS works similarly to DFS but it distinguishes itself by visiting a root's neighbors first, rather than it's descendants. We accomplish this by replacing our stack from DFS with a queue.</p>\",\n    'a*_solver': \"<p class='algo-title'>A*</p>1. Initialize a set with a single node.<br/>2. Remove the node with the least f value* from the set.<br/>3. For each of the node's nieghbors:<br/>  3a. Calculate f value.<br/> 3b. If there is a visited node with the same coordinates and a lower f-value, discard the neighbor. Else, add it to the set.<br/>Repeat steps 2-3 until the target is reached.<br/><br/>* F-value = number of steps from the root + euclidean distance from the target.</p>\",\n    'quick_maze': \"<p class='algo-title'>Quick Maze</p><br/><p>To generate a quick maze, the machine randomly selects either Prim's algorithm or Randomized DFS.</p>\"\n  }\n\n\n  document.getElementById('prims_generator').addEventListener(\"click\", () => {\n    document.getElementById('description').innerHTML = descriptions['prims'];\n    generateMaze(null, 'prims', primsDfsGenerator);\n  })\n\n  document.getElementById('randomized_dfs_generator').addEventListener(\"click\", () => {\n    document.getElementById('description').innerHTML = descriptions['randomized_dfs'];\n    generateMaze(null, null, randomized_dfs_generator);\n  })\n\n  document.getElementById('strict_dfs_generator').addEventListener(\"click\", () => {\n    document.getElementById('description').innerHTML = descriptions['strict_dfs'];\n    generateMaze(null, 'dfs', primsDfsGenerator, [0, 0]);\n  })\n\n  document.getElementById('quick_maze').addEventListener(\"click\", () => {\n    document.getElementById('description').innerHTML = descriptions['quick_maze'];\n    const generator = quickGenerators[Math.floor(Math.random() * quickGenerators.length)];\n    generateMaze('quick', 'prims', generator, [0, 0]);\n  })\n\n  document.getElementById('dfs_solver').addEventListener(\"click\", () => {\n    document.getElementById('description').innerHTML = descriptions['dfs_solver'];\n    maze_solver(ctx, root, grid.matrix[48][48], grid, 'dfs');\n  })\n\n  document.getElementById('bfs_solver').addEventListener(\"click\", () => {\n    document.getElementById('description').innerHTML = descriptions['bfs_solver'];\n    maze_solver(ctx, root, grid.matrix[48][48], grid, 'bfs');\n  })\n\n  document.getElementById('a*_solver').addEventListener(\"click\", () => {\n    document.getElementById('description').innerHTML = descriptions['a*_solver'];\n    maze_solver(ctx, root, grid.matrix[48][48], grid, 'a*');\n  })\n}\n\nexport default mazeHandlers;\n","import MinHeap from '../components/min_heap';\nimport changeButtonStatus from '../button_util';\n\nconst maze_solver = (ctx, root, target, grid, algo) => {\n  changeButtonStatus(true);\n  grid.clearSolution(ctx);\n\n  const euclideanDist = (current, target) => {\n    return Math.sqrt(\n      Math.pow((target.x - current.x), 2) +\n      Math.pow((target.y - current.y), 2)\n    )\n  };\n  const comparator = (node1, node2) => {\n    return node1.fVal > node2.fVal;\n  }\n  root.gVal = 0;\n  let options = algo === 'a*' ? new MinHeap(comparator, root) : [root];\n  debugger\n  const solutionStep = () => {\n    let selected = algo === 'dfs' ? options.pop() : options.shift();\n    debugger\n    grid.drawPath(ctx, selected, '#fffbfb');\n\n    if(selected.x === target.x && selected.y === target.y) {\n\n      grid.drawSolution(root, target, ctx);\n      clearInterval(timer);\n      changeButtonStatus(false);\n    }\n\n    selected.children.forEach(child => {\n      if (child.onPath) {\n\n        if (algo === 'a*') {\n          child.gVal = child.parent.gVal + 1;\n          child.hVal = euclideanDist(child, target);\n          child.fVal = child.gVal + child.hVal;\n        }\n\n        options.push(child);\n      };\n    });\n  }\n\n  const timer = setInterval(solutionStep, 0);\n}\n\nexport default maze_solver;\n"],"sourceRoot":""}