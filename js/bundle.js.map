{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/components/grid.js","webpack:///./js/components/node.js","webpack:///./js/generators/master_generator.js","webpack:///./js/index.js","webpack:///./js/solvers/dfs_bfs_solver.js","webpack:///./js/util/canvas_util.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,0CAA0C,eAAe;AACzD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;ACzCA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;;;ACPgC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;ACxBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/index.js\");\n","import Node from './node';\n\nclass Grid {\n  constructor(gridDimensions){\n    this.xDim = gridDimensions[0];\n    this.yDim = gridDimensions[1];\n    this.matrix = this.constructMatrix();\n  }\n\n  constructMatrix() {\n    let matrix = [];\n\n    for(let i = 0; i < this.yDim; i++) {\n      let row = [];\n      for(let j = 0; j < this.xDim; j++) {\n        const node = new Node([j, i], null);\n        row.push(node);\n      }\n      matrix.push(row);\n    }\n\n    return matrix;\n  }\n\n\n  intersectsPath(node) {\n    if(this.matrix[node.x][node.y].path) { return true };//if there is already a path node at this space\n    node.neighborCoords.forEach(coords => {\n      if(this.inBounds(coords[0], coords[1])){\n\n        const neighbor = this.matrix[coords[0]][coords[1]];\n\n        if(neighbor !== node.parent && neighbor.path) {\n          return true;\n        }\n      }\n\n    });\n    return false;\n  }\n\n  continuePath(node) {\n    this.matrix[node.x][node.y] = node;\n  }\n\n  inBounds(x, y){\n    return (x >= 0 && x < this.xDim) && (y >= 0 && y < this.yDim)\n  }\n}\n\nexport default Grid;\n","\nclass Node {\n  constructor(rootCoords, path) {\n    this.x = rootCoords[0];\n    this.y = rootCoords[1];\n    this.path = path;\n    this.parent = null;\n    this.parent_connector = null;\n    this.neighborCoords = [\n      [this.x + 2, this.y],\n      [this.x - 2, this.y],\n      [this.x, this.y + 2],\n      [this.x, this.y - 2]\n    ]\n    this.children = null;\n  }\n\n  generateChildren(grid) {\n    this.children = this.neighborCoords.map(coords => {\n      const child = new Node(coords, true);\n      child.parent = this;\n      const parent_connector = new Node ([(child.x + child.parent.x) / 2, (child.y + child.parent.y) / 2], true);\n      child.parent_connector = parent_connector;\n\n      return child;\n    }).filter(child => {\n      return grid.inBounds(child.x, child.y);\n    });\n  }\n\n  removeChild(reject) {\n    const newChildren = this.children.filter(child => {\n      return child.x !== reject.x && child.y !== reject.y;\n    });\n\n    this.children = newChildren;\n  }\n}\n\nexport default Node;\n","import Grid from '../components/grid';\nimport Node from '../components/node';\nimport dfs_bfs_solver from '../solvers/dfs_bfs_solver';\nimport { drawPath } from '../util/canvas_util';\n\nconst generate_maze = (canvas, rootCoords, gridDimensions) => {\n  //\n  const grid = new Grid(gridDimensions);\n  const root = new Node(rootCoords, true);\n  const ctx = canvas.getContext('2d');\n  let options = [root];\n\n  const generationStep = () => {\n    // if(options.length === 0) {\n    //   window.clearInterval(timer);\n    //   dfs_bfs_solver(ctx, root, grid.matrix[99][99], 'dfs');\n    //   return;\n    // };\n\n    let randomIndex = Math.floor(Math.random() * options.length);\n    let selected = options.splice(randomIndex, 1)[0];\n\n    if(!grid.intersectsPath(selected)) {\n      grid.continuePath(selected);\n      drawPath(ctx, selected, \"#2ae950\");\n      selected.generateChildren(grid);\n      options = options.concat(selected.children);\n\n    } else {\n      selected.parent.removeChild(selected);\n    }\n  }\n\n  while(options.length > 0){\n    generationStep();\n  }\n  dfs_bfs_solver(ctx, root, grid.matrix[99][99], 'dfs');\n\n  // const timer = window.setInterval(generationStep, 0);\n}\n\nexport default generate_maze;\n","import generate_maze from './generators/master_generator';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvas = document.getElementById('maze');\n  canvas.addEventListener(\"click\", () => {\n    generate_maze(canvas, [0, 0], [100, 100]);\n  });\n});\n","import { drawPath, drawSolution } from '../util/canvas_util';\n\nconst dfs_bfs_solver = (ctx, root, target, algo) => {\n  let options = [root];\n\n  const solutionStep = () => {\n    let selected = algo === 'dfs' ? options.pop() : options.shift();\n    debugger\n    drawPath(ctx, selected, \"#872bc4\");\n    if(selected.x === target.x && selected.y === target.y) {\n      drawSolution(root, target, ctx);\n      return;\n\n    }\ndebugger\n    if(selected.children) {\n      options = options.concat(selected.children);\n      debugger\n    }\n  }\n\n  setInterval(solutionStep, 0);\n}\n\nexport default dfs_bfs_solver;\n","export const drawSolution = (root, target, ctx) => {\n  const path = [target];\n\n  while(path[0].x !== root.x || path[0].y !== root.y) {\n    let node = path[0].parent;\n    path.unshift(node);\n  }\n\n  const drawStep = () => {\n    path.forEach(node => {\n      drawPath(ctx, node, '#ff2103')\n    });\n  }\n\n  const timer = setInterval(drawStep, 0);\n}\n\nexport const drawPath = (ctx, node, color) => {\n  ctx.fillStyle = color;\n\n  if(node.parent_connector){\n    ctx.fillRect(node.parent_connector.x * 5, node.parent_connector.y * 5, 5, 5);\n  }\n  ctx.fillRect(node.x * 5, node.y * 5, 5, 5);\n}\n"],"sourceRoot":""}