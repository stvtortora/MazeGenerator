{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/components/disjoint_set.js","webpack:///./js/components/grid.js","webpack:///./js/components/min_heap.js","webpack:///./js/components/node.js","webpack:///./js/generators/kruskals_generator.js","webpack:///./js/generators/master_generator.js","webpack:///./js/generators/prims_dfs_generator.js","webpack:///./js/generators/randomized_dfs_generator.js","webpack:///./js/index.js","webpack:///./js/solvers/maze_solver.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACnEA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACdA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AChEA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;ACrCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL,G;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;AChDA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;;;AAIA;;;;;;;;;;;;;;;;AChFA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;;;;;;;;;;;;;;;ACfA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACzCA;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;ACfD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/index.js\");\n","class DisjointSet {\n\n  joined(node1, node2) {\n    debugger\n    return node1.setRoot() === node2.setRoot();\n  }\n\n  merge(set1, set2) {\n    debugger\n    set2.setRoot().setParent = set1.setRoot();\n    debugger\n  }\n}\n\nexport default DisjointSet;\n","import Node from './node';\n\nclass Grid {\n  constructor(gridDimensions){\n    this.xDim = gridDimensions[0];\n    this.yDim = gridDimensions[1];\n    this.matrix = this.constructMatrix();\n  }\n\n  constructMatrix() {\n    let matrix = [];\n\n    for(let i = 0; i < this.yDim; i++) {\n      let row = [];\n      for(let j = 0; j < this.xDim; j++) {\n        const node = new Node([i, j], null);\n        row.push(node);\n      }\n      matrix.push(row);\n    }\n\n    return matrix;\n  }\n\n  inBounds(x, y){\n    return (x >= 0 && x < this.xDim) && (y >= 0 && y < this.yDim)\n  }\n\n  openAt(x, y) {\n    return !this.matrix[x][y].onPath;\n  }\n\n  continuePath(node, ctx) {\n    this.matrix[node.x][node.y] = node;\n    node.onPath = true;\n    this.drawPath(ctx, node, \"#2ae950\");\n  }\n\n  drawSolution (root, target, ctx) {\n    const path = [target];\n    while(path[0].x !== root.x || path[0].y !== root.y) {\n      let node = path[0].parent;\n      path.unshift(node);\n    }\n\n    const drawStep = () => {\n      path.forEach(node => {\n        this.drawPath(ctx, node, '#ff2103')\n      });\n    }\n\n    const timer = setInterval(drawStep, 0);\n  }\n\n  drawPath(ctx, node, color) {\n    const multiplier = 10;\n    ctx.fillStyle = color;\n    if(node.parent_connector){\n      ctx.fillRect(node.parent_connector.x * multiplier, node.parent_connector.y * multiplier, multiplier, multiplier);\n    }\n    ctx.fillRect(node.x * multiplier, node.y * multiplier, multiplier, multiplier);\n  }\n}\n\nexport default Grid;\n","class MinHeap {\n  constructor(comparator, root) {\n    this.comparator = comparator;\n    this.array = [root];\n    this.length = 1;\n  }\n\n  shift() {\n    this.length--;\n    return this.array.shift();\n  }\n\n  push(node) {\n    this.array.push(node);\n    this.length++;\n    this.heapify();\n  }\n\n  swap(x, y) {\n    let temp = this.array[x];\n    this.array[x] = this.array[y];\n    this.array[y] = temp;\n  }\n\n  heapify() {\n    let index = this.length - 1;\n    let parentIndex = Math.floor((index - 1) / 2);\n\n    while(parentIndex > -1 && this.comparator(this.array[parentIndex], this.array[index])) {\n      this.swap(parentIndex, index);\n      index = parentIndex;\n      parentIndex =  Math.floor((index - 1) / 2);\n    }\n  }\n\n}\n\nexport default MinHeap;\n","class Node {\n  constructor(rootCoords, onPath) {\n    this.x = rootCoords[0];\n    this.y = rootCoords[1];\n    this.onPath = onPath;\n    this.parent = null;\n    this.parent_connector = null;\n    this.children = [];\n    this.adjacentCoords = [\n      [this.x + 2, this.y],\n      [this.x - 2, this.y],\n      [this.x, this.y + 2],\n      [this.x, this.y - 2]\n    ]\n    this.gVal = null;\n    this.hVal = null;\n    this.fVal = null;\n    this.setParent = null;\n  }\n\n  generateChild(coords) {\n    const child = new Node(coords, null);\n    child.parent = this;\n    const parent_connector = new Node ([(child.x + child.parent.x) / 2, (child.y + child.parent.y) / 2], null);\n    child.parent_connector = parent_connector;\n\n    this.children.push(child);\n  }\n\n  generateChildren(grid) {\n    this.children = this.adjacentCoords.map(coords => {\n      const child = new Node(coords, null);\n      child.parent = this;\n      const parent_connector = new Node ([(child.x + child.parent.x) / 2, (child.y + child.parent.y) / 2], null);\n      child.parent_connector = parent_connector;\n\n      return child;\n    }).filter(child => {\n      return grid.inBounds(child.x, child.y);\n    });\n  } \n\n  setRoot() {\n    return this.setParent ? this.setParent.setRoot() : this;\n  }\n\n}\n\nexport default Node;\n","import maze_solver from '../solvers/maze_solver';\nimport DisjointSet from '../components/disjoint_set';\n\nconst kruskals_generator = (grid, root, canvas, algo) => {\n  const disjointSet = new DisjointSet;\n  const flatten = (array) => {\n    let flattened = [];\n\n    for (let i = 0; i < array.length; i++) {\n      const el = array[i];\n      if (Array.isArray(el)){\n        flattened = flattened.concat(flatten(el));\n      } else{\n        flattened.push(el);\n      }\n    }\n\n    return flattened;\n  }\n\n  const rejectWalls = (nodes) => {\n    return nodes.filter(node => {\n      return node.x % 2 === 0 && node.y % 2 === 0;\n    });\n  }\n\n  const shuffle = (array) => {\n    for(let i = 0; i < array.length; i++) {\n      let j = Math.floor(Math.random() * array.length);\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n  }\n\n  const ctx = canvas.getContext('2d');\n  let options = rejectWalls(flatten(grid.matrix));\ndebugger\n\n  const generationStep = () => {\n    if(options.length === 0) {\n\n      // checkSets();\n      window.clearInterval(timer);\n      // maze_solver(ctx, root, grid.matrix[48][48], grid, algo);\n      return;\n    };\n\n    let randomIndex = Math.floor(Math.random() * options.length);\n    const selected = options[randomIndex];\n\n    if(selected.adjacentCoords.length > 0){\n      let randomIndex = Math.floor(Math.random() * selected.adjacentCoords.length);\n      const coords = selected.adjacentCoords.splice(randomIndex, 1)[0];\n\n      if(grid.inBounds(coords[0], coords[1])){\n        const neighbor = grid.matrix[coords[0]][coords[1]];\n\n        if(!disjointSet.joined(selected, neighbor)){\n          debugger\n          disjointSet.merge(selected, neighbor);\n          neighbor.parent = selected;\n\n          neighbor.parent_connector = grid.matrix[(neighbor.x + selected.x) / 2][(neighbor.y + selected.y) / 2];\n          grid.continuePath(selected, ctx);\n          grid.continuePath(neighbor, ctx);\n        }\n\n      }\n\n    } else{\n      options.splice(randomIndex, 0);\n    }\n\n  }\n\n  const timer = setInterval(generationStep, 0);\n}\n\n\n\nexport default kruskals_generator;\n","import Grid from '../components/grid';\nimport Node from '../components/node';\n\nconst maze = (maze_generator, canvasId, rootCoords, gridDimensions, solve_algo, gen_algo) => {\n  const grid = new Grid(gridDimensions);\n  const root = new Node(rootCoords, null);\n  // const root = grid.matrix[rootCoords[0]][rootCoords[1]];\n  const canvas = document.getElementById(canvasId);\n  canvas.addEventListener(\"click\", ()=> {\n    debugger\n    maze_generator(grid, root, canvas, solve_algo, gen_algo);\n  });\n}\n\n\nexport default maze;\n","import maze_solver from '../solvers/maze_solver';\n\nconst primsDfsGenerator = (grid, root, canvas, solve_algo, gen_algo) => {\n\n  const ctx = canvas.getContext('2d');\n  let options = [root];\n\n  const generationStep = () => {\n    if(options.length === 0) {\n      window.clearInterval(timer);\n      // maze_solver(ctx, root, grid.matrix[48][48], grid, algo);\n      return;\n    };\n\n    let selected;\n    if(gen_algo === 'prims') {\n      let randomIndex = Math.floor(Math.random() * options.length);\n      selected = options.splice(randomIndex, 1)[0];\n    } else{\n      selected = options.pop();\n    }\ndebugger\n\n    if(grid.openAt(selected.x, selected.y)) {\n      grid.continuePath(selected, ctx);\n      selected.generateChildren(grid);\ndebugger\n      options = options.concat(selected.children);\n    }\n  }\n\n  if(solve_algo){\n    while(options.length > 0){\n      generationStep();\n    }\n    maze_solver(ctx, root, grid.matrix[48][48], grid, solve_algo);\n  } else{\n    const timer = window.setInterval(generationStep, 0);\n  }\n\n}\nexport default primsDfsGenerator;\n","import maze_solver from '../solvers/maze_solver';\n\nconst randomized_dfs_generator = (grid, root, canvas, algo) => {\n  const shuffle = (array) => {\n    for(let i = 0; i < array.length; i++) {\n      let j = Math.floor(Math.random() * array.length);\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n  }\n\n  const ctx = canvas.getContext('2d');\n  grid.continuePath(root, ctx);\n  let options = [root];\n\n  const generationStep = () => {\n    if(options.length === 0) {\n      window.clearInterval(timer);\n      // maze_solver(ctx, root, grid.matrix[48][48], grid, algo);\n      return;\n    };\n\n    const parent = options[options.length - 1];\n    const childCoords = shuffle(parent.adjacentCoords);\n    let checked = 0\n    let selected = null;\n\n    while(checked < childCoords.length && !selected){\n      let coords = childCoords[checked];\n\n      if(grid.inBounds(coords[0], coords[1]) && grid.openAt(coords[0], coords[1])){\n        debugger\n        parent.generateChild(coords);\n        let child = parent.children[parent.children.length - 1];\n        grid.continuePath(child, ctx);\n        selected = child;\n\n      }\n\n      checked++;\n    }\n\n    selected ? options.push(selected) : options.pop();\n  }\n\n  const timer = setInterval(generationStep, 0);\n}\n\n\nexport default randomized_dfs_generator;\n","import maze from './generators/master_generator';\nimport primsDfsGenerator from './generators/prims_dfs_generator';\nimport randomized_dfs_generator from './generators/randomized_dfs_generator';\nimport kruskals_generator from './generators/kruskals_generator';\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    maze(primsDfsGenerator, '1', [0, 0], [50, 50], null, 'dfs');\n    maze(randomized_dfs_generator, '2', [0, 0], [50, 50], null);\n    maze(primsDfsGenerator, '3', [0, 0], [50, 50], null, 'prims');\n    maze(kruskals_generator, '4', [0, 0], [50, 50], null, null);\n    maze(primsDfsGenerator, '5', [0, 0], [50, 50], 'dfs', 'prims');\n    maze(primsDfsGenerator, '6', [0, 0], [50, 50], 'bfs', 'prims');\n    maze(primsDfsGenerator, '7', [0, 0], [50, 50], 'a*', 'prims');\n});\n","import MinHeap from '../components/min_heap';\n\nconst maze_solver = (ctx, root, target, grid, algo) => {\n  const euclideanDist = (current, target) => {\n    return Math.sqrt(\n      Math.pow((target.x - current.x), 2) +\n      Math.pow((target.y - current.y), 2)\n    )\n  };\n  const comparator = (node1, node2) => {\n    return node1.fVal > node2.fVal;\n  }\n  root.gVal = 0;\n  let options = algo === 'a*' ? new MinHeap(comparator, root) : [root];\n\n  const solutionStep = () => {\n    let selected = algo === 'dfs' ? options.pop() : options.shift();\n    grid.drawPath(ctx, selected, \"#000000\");\n\n    if(selected.x === target.x && selected.y === target.y) {\n\n      grid.drawSolution(root, target, ctx);\n      clearInterval(timer);\n    }\n\n    selected.children.forEach(child => {\n      if (child.onPath) {\n\n        if (algo === 'a*') {\n          child.gVal = child.parent.gVal + 1;\n          child.hVal = euclideanDist(child, target);\n          child.fVal = child.gVal + child.hVal;\n        }\n\n        options.push(child);\n      };\n    });\n\n  }\n\n  const timer = setInterval(solutionStep, 0);\n}\n\nexport default maze_solver;\n"],"sourceRoot":""}